#takes the json file imported or generated by other loaders and returns python objects
import os
import json
from at import  elements as ele
import at
from file_io.elegant_loader import load_elegant
from file_io.opa_loader import load_opa
from file_io.madx_loader import load_madx
from file_io.py_loader import load_pyat
# from core.elements import Drift, Quadrupole,Sextupole,Dipole

def load_file(path):
    """This function loads the given file and by getting the file type and using the dedicated loading function.
    Returns: The lattice with metadata and elements for self.lattice_data"""
    _, ext = os.path.splitext(path)

    if ext.lower() == ".json":
        with open(path, "r") as file:
            data = json.load(file)
    elif ext.lower() == ".opa":
        data = load_opa(path)
    elif ext.lower() == ".madx":
        data = load_madx(path)
    elif ext.lower() == ".py":
        data = load_pyat(path)
    sections = data.get("lattices",{})
    metadata = data.get("parameters", {})
    metadata["name"] = data.get("title")
    energy = metadata.get("energy_GeV")
    elements = build_element_objects(data.get("elements", {}), data.get("lattices", {}),energy =energy)
    return sections,metadata, elements

def build_element_objects(elements, lattices,energy):
    """This function resolve the recursive construction of lattices in files.
    Returns: pyAT lattices of the loaded file"""
    element_map = {}
    def resolve_element(name, reverse=False):
        # Ist es ein echtes Element?
        
        if name.startswith("-"):
            base_name = name[1:]
            if base_name in lattices:
                return resolve_element(base_name, reverse=not reverse)
            elif base_name in elements:
                return resolve_element(base_name)
        if "*" in name:
            n, base_name = name.split("*",1)
            n =int(n.strip())
            return sum([resolve_element(base_name.strip(),reverse =reverse) for _ in range(n)], [])
        if name in elements:
            data = elements[name]
            elem_type = data.get("type", "").lower()
            length = data.get("length", 0.0)
            if elem_type == "drift":
                
                return [ele.Drift(family_name=name, length=length)]
            elif elem_type == "quadrupole":
                
                return [ele.Quadrupole(family_name=name, length=length, k=data.get("k1", 0.0))]
            elif elem_type == "sextupole":
                hval =data.get("k2")
                if hval is None:
                    hval = data.get("k1",0.0)
                return [ele.Sextupole(family_name=name, length=length, h=hval)]
            elif elem_type == "dipole":
                
                return [ele.Dipole(family_name=name, length=length, BendingAngle=data.get("angle", 0.0), k = data.get("k1",0.0))]
            elif elem_type == "marker":
                
                return [ele.Marker(family_name=name)]
            elif elem_type == "rf_cavity":
                
                return[ele.RFCavity(family_name=name, length=length, voltage= data.get("voltage_kV",0.0)*1000,frequency=data.get("rf_frequency",0.0), harmonic_number= data.get("harmonic_number",0.0),energy=data.get("energy",0.0))]
            else:
                return []
        elif name in lattices:
            names = lattices[name]
            if reverse:
                names = list(reversed(names))
            section = []
            for n in names:
                section.extend(resolve_element(n, reverse=reverse))
            return section
        elif "=" in name:
            return []
        print(f"Warnung: Element oder Section '{name}' nicht gefunden!")
        return []
        
    for section_name, element_names in lattices.items():
        section_elements = []
        
        for name in element_names:
            section_elements.extend(resolve_element(name))
        element_map[section_name] = at.Lattice(section_elements,energy= energy)

    return element_map
